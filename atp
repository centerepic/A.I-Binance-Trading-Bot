# -*- coding: utf-8 -*-
"""
Created on Mon Jan  8 06:16:20 2024

@author: azzy
"""
from keys import *
# importing keys
import multiprocessing
import pandas as pd
import numpy as np #computing multidimensionla arrays
from datetime import datetime
from time import sleep
from binance.client import Client
from binance import *
from binance.enums import *
import math
import pandas_ta as ta
import operator
import os
import sys
import ast
globalInterval=Client.KLINE_INTERVAL_5MINUTE
########close/open trades###########
def Lsafe(client,Seed,mrgType,lvrg):
    try:
        client.futures_change_leverage(symbol=Seed,leverage=lvrg)
        client.futures_change_margin_type(symbol=Seed,marginType=mrgType)
    except:
        return
    
#Precession
def get_current_datetime_as_string():
    current_datetime = datetime.now()
    return current_datetime.strftime("%Y-%m-%d %H:%M:%S")

def truncate(number, precision):
    factor = 10.0 ** precision
    return int(number * factor) / factor

def LongOrder(client, Seed, precision, numBots, lvrg):
    balance = client.futures_account_balance()
    bal = None
    
    for wc in balance:
        if wc["asset"] == 'USDT':
            bal = float(wc["balance"])
            break

    if bal is None:
        return "No USDT balance found"

    percent = 1 / numBots  # Calculate the percentage of balance to use for each bot

    price = float(client.futures_mark_price(symbol=Seed)["markPrice"])
    maxl = (bal * percent) * lvrg
    maxq = maxl / price
    q = truncate(maxq, precision)

    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_BUY, quantity=str(q))
        return str(q)
    except:
        return "null"

def ShortOrder(client, Seed, precision, numBots, lvrg):
    balance = client.futures_account_balance()
    bal = None
    
    for wc in balance:
        if wc["asset"] == 'USDT':
            bal = float(wc["balance"])
            break

    if bal is None:
        return "No USDT balance found"

    percent = 1 / numBots  # Calculate the percentage of balance to use for each bot

    price = float(client.futures_mark_price(symbol=Seed)["markPrice"])
    maxl = (bal * percent) * lvrg
    maxq = maxl / price
    q = truncate(maxq, precision)

    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_SELL, quantity=str(q))
        return str(q)
    except:
        return "null"

def closeLong(client, p, Seed):
    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_SELL, quantity=p, reduceOnly='true')
        return f"Closed long position with quantity {p}"
    except:
        return "null"

def closeShort(client, p, Seed):
    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_BUY, quantity=p, reduceOnly='true')
        return f"Closed short position with quantity {p}"
    except:
        return "null"
    
########close/open trades###########

#################### Get token info #########################

def batchCollector(excludedlist,CurrencyType):
    client = Client(api_key, api_secret)
    exInfo=client.futures_exchange_info()
    tokenInf,sinf=FindNewToken(client,exInfo,excludedlist,CurrencyType)
    Ftoken_list=OpenLayer(tokenInf)
    return Ftoken_list,sinf

def TokenInfo(client,sym,CurrencyType):
    try:
        candles = client.futures_continous_klines(pair=sym, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        return df
    except Exception as e:
        #TokenInfo error Removed from Market or not added yet
        print("TokenInfo error Removed from Market or not added yet",e)

def FindNewToken(client,exInfo,excludedlist,CurrencyType):
    symInfo={}
    tokenInfo={}
    for symbol in exInfo["symbols"]:
        if symbol["contractType"]=="PERPETUAL" and symbol["symbol"] not in excludedlist and CurrencyType in symbol["symbol"] and symbol["status"]=="TRADING":
            symInfo[symbol["symbol"]]=symbol["quantityPrecision"]
    x=0
    for key,values in symInfo.items():
        result=TokenInfo(client,key,CurrencyType)
        tokenInfo[key]=result
        if x==30:
            print("30%")
        if x==80:
            print("80%")
        if x==130:
            print("99%")
        x+=1
    print('100%')            
    return tokenInfo,symInfo

def OpenLayer(TokenInfo):
    ranked_result={}
    trade_types=['FL','FS','RL','RS']
    for Ti,value in TokenInfo.items():
        pressurelist={}
        try:
            TZSCORE=zscore(value)
            TCMF=CMF(value)
            TRSI=rsi(value)
            TMACD=MACD(value)
            for ttype in trade_types:
                range_intensity=is_between_open(TRSI,TCMF,TMACD,ttype)
                if range_intensity>trigger_amount(ttype,'open'):
                    pressurelist[ttype]=round((range_intensity+abs(TZSCORE)),2)
        except Exception as e:
            #TokenInfo error Removed from Market or not added yet
            print("TokenInfo error Removed from Market or not added yet",e)
        bestchoice=get_key_of_higher_number(pressurelist)
        if bestchoice != None:
            ranked_result[Ti]=[pressurelist[bestchoice],bestchoice]
    # Sort the keys based on the first element of the list in descending order
    sorted_keys = sorted(ranked_result.keys(), key=lambda x: ranked_result[x][0], reverse=True)
    # Reorganize the dictionary using the sorted keys
    sorted_ranked_result = {key: ranked_result[key] for key in sorted_keys}
    print(sorted_ranked_result)
    Tresult={}
    for key,item in sorted_ranked_result.items():
        Tresult[key]=item[1]
    return Tresult

def get_key_of_higher_number(dictionary):
    # Initialize variables to keep track of the highest number and its corresponding key
    highest_number = float('-inf')  # Start with a very low number
    highest_key = None

    # Iterate through the dictionary
    for key, value in dictionary.items():
        # If the current value is higher than the highest number found so far
        if value > highest_number:
            highest_number = value
            highest_key = key
    # Return the key corresponding to the highest number
    return highest_key

#problem rippling solution
def is_between_open(TRSI,TCMF,TMACD,ttype):
    range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[0]
    range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[0]
    range_macd=ast.literal_eval(read_matching_table('nodes','MACD', ttype))[0]
    RSI_intensity= intensity_from_mid(TRSI, range_rsi)
    CMF_intensity= intensity_from_mid(TCMF, range_cmf)
    MACD_intensity=intensity_from_mid(TMACD, range_macd)
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[0]
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[0]
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', ttype))[0]
    average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + (macd_w * MACD_intensity)),2)
    return average

def is_between_close(TRSI,TCMF,TMACD,ttype):
    range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[1]
    range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[1]
    range_macd=ast.literal_eval(read_matching_table('nodes','MACD', ttype))[1]
    RSI_intensity= intensity_from_mid(TRSI, range_rsi)
    CMF_intensity= intensity_from_mid(TCMF, range_cmf)
    MACD_intensity=intensity_from_mid(TMACD, range_macd)
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[1]
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[1]
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', ttype))[1]
    average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + (macd_w * MACD_intensity)),2)
    return average

#################### Get token info #########################

############# Indicators #############
def CMF(data):
    period = 20
    mf = ((data['close'] - data['low']) - (data['high'] - data['close'])) / (data['high'] - data['low'])
    mfv = mf * data['volume']
    cmf_values = mfv.rolling(period).sum() / data['volume'].rolling(period).sum()
    cmf_values = cmf_values.dropna() 
    return round(cmf_values.iloc[-1],2)

def rsi(dataset, period=14):
    # Calculate daily returns
    delta = dataset['close'].diff()
    
    # Separate positive and negative gains/losses
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    
    # Calculate average gain and loss
    avg_gain = gain.rolling(window=period, min_periods=1).mean()
    avg_loss = loss.rolling(window=period, min_periods=1).mean()
    
    # Calculate the Relative Strength (RS)
    rs = avg_gain / avg_loss
    
    # Calculate the RSI
    rsi = 100 - (100 / (1 + rs))
    
    # Extract the last RSI value and round it to 2 decimal places
    rsi_value = round(rsi.iloc[-1], 2)
    
    return rsi_value

def zscore(dataset):
    # Calculate the mean of the dataset
    mean = dataset['close'].mean()
    
    # Calculate the standard deviation of the dataset
    std_dev = dataset['close'].std()
    
    # Calculate the z-score for the most recent data point
    zscore = (dataset['close'].iloc[-1] - mean) / std_dev
    
    # Round the z-score to 2 decimal places
    zscore = round(zscore, 2)
    
    return zscore

def calculate_ema(series, span):
    return series.ewm(span=span, adjust=False).mean()

def MACD(dataset, short_period=12, long_period=26, signal_period=9):
    # Calculate the short-term EMA (12-day EMA)
    short_ema = calculate_ema(dataset['close'], short_period)
    
    # Calculate the long-term EMA (26-day EMA)
    long_ema = calculate_ema(dataset['close'], long_period)
    
    # Calculate the MACD line
    macd_line = short_ema - long_ema
    
    # Calculate the Signal line (9-day EMA of the MACD line)
    signal_line = calculate_ema(macd_line, signal_period)
    
    # Calculate the MACD Histogram
    macd_histogram = macd_line - signal_line
    
    # Normalize the MACD Histogram to a range from -100 to 100
    max_abs_histogram = macd_histogram.abs().max()
    normalized_histogram = (macd_histogram / max_abs_histogram) * 100
    
    # Extract the latest MACD, Signal, and Histogram values
    # latest_macd = round(macd_line.iloc[-1], 2)
    # latest_signal = round(signal_line.iloc[-1], 2)
    latest_histogram = round(normalized_histogram.iloc[-1], 2)
    
    return int(latest_histogram)


def intensity_from_mid(number, range_list):
    if len(range_list) != 2:
        raise ValueError("Range list must contain exactly two elements.")
    
    # Sort the range automatically
    sorted_range = sorted(range_list)
    range_start, range_end = sorted_range[0], sorted_range[1]

    if range_start == range_end:
        raise ValueError("Range start and end cannot be the same.")
    
    if not (range_start <= number <= range_end):
        return 0  # If the number is out of the specified range, intensity is 0.

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Calculate the distance of the number from the midpoint
    distance_from_midpoint = abs(number - midpoint)

    # Calculate the maximum distance from the midpoint (half the range)
    max_distance = (range_end - range_start) / 2

    # Calculate the intensity based on the distance from the midpoint
    intensity = 1 - (distance_from_midpoint / max_distance)
    
    return intensity

############# Indicators #############

########################database##############

def nodes():
    if not os.path.exists('nodes.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI', 'CMF','MACD'],
            'FL': ['[[52.15, 62.15], [18.86, 28.86]]', '[[0.08, 0.58], [-0.13, 0.37]]', '[[39.75, 49.75], [-22.75, -12.75]]'],
            'FS': ['[[18.86, 28.86], [52.15, 62.15]]', '[[-0.13, 0.37], [0.08, 0.58]]', '[[-22.75, -12.75], [39.75, 49.75]]'],
            'RL': ['[[8.86, 18.86], [42.15, 52.15]]', '[[-0.63, -0.13], [-0.42, 0.08]]', '[[-32.75, -22.75], [29.75, 39.75]]'],
            'RS': ['[[42.15, 52.15], [8.86, 18.86]]', '[[-0.42, 0.08], [-0.63, -0.13]]', '[[29.75, 39.75], [-32.75, -22.75]]']
        }
        df = pd.DataFrame(data)
        df.to_csv('nodes.csv', index=False)
        return df
    else:
        df=pd.read_csv('nodes.csv')
        return df
def reflections():
    if not os.path.exists('reflections.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI','CMF','MACD','TNUM'],
            'ref': ['[6969,6969]','[6969,6969]','[6969,6969]','0'],
            }
        df = pd.DataFrame(data)
        df.to_csv('reflections.csv', index=False)
        return df
    else:
        df=pd.read_csv('reflections.csv')
        return df
def weights():
    if not os.path.exists('weights.csv'):
        # Create a DataFrame with the desired structure '[1,1]', '[1,1]', '[1,1]', '[1,1]',
        data = {
            'IND': ['RSI', 'CMF','MACD'],
            'FL': ['[1,1]', '[1,1]','[1,1]'],
            'FS': ['[1,1]', '[1,1]','[1,1]'],
            'RL': ['[1,1]', '[1,1]','[1,1]'],
            'RS': ['[1,1]', '[1,1]','[1,1]']
            }
        df = pd.DataFrame(data)
        df.to_csv('weights.csv', index=False)
        return df
    else:
        df=pd.read_csv('weights.csv')
        return df
    
def read_matching_table(table,indicator, column_name):
    if table=='nodes':   
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    
def update_cell_table(table,indicator, column_name, new_value):
    if table=='nodes':
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('nodes.csv', index=False)
        return True
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('weights.csv', index=False)
        return True
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('reflections.csv', index=False)
        return True

def multiTokenHistory():
    if not os.path.exists('multiTokenHistory.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'price': [],
            'CMF': [],
            'RSI': [],
            'MACD': []
        }
        df = pd.DataFrame(data)
        df.to_csv('multiTokenHistory.csv', index=False)
        return df
    else:
        df=pd.read_csv('multiTokenHistory.csv')
        return df

def TradeLog():
    if not os.path.exists('TradeLog.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'type': [],
            'datetime': [],
            'opprice': [],
            'result':[],
            'status': []
        }
        df = pd.DataFrame(data)
        df.to_csv('TradeLog.csv', index=False)
        return df
    else:
        df=pd.read_csv('TradeLog.csv')
        return df

def clear_tradeLog():
    try:
        os.remove("TradeLog.csv")
        print(" TradeLog.csv deleted successfully.")
    except FileNotFoundError:
        print("File TradeLog.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")

def add_tradeLog(Ti, ttype, datetime, opprice,result,amount,status):
    dataframe=TradeLog()
    new_row = pd.DataFrame({
        'token': Ti,
        'type': ttype,
        'datetime': datetime,
        'opprice': opprice,
        'amount': amount,
        'result': result,
        'status': status
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv('TradeLog.csv', index=False)
    
def update_cell_Tlog(token, column_name, new_value):
    df=TradeLog()
    row_index = df.index[df['token'] == token ].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    df.iloc[row_index[0], column_index] = new_value
    df.to_csv('TradeLog.csv', index=False)
    return True

def read_matching_TLog(token, column_name):
    df=TradeLog()
    row_index = df.index[df['token'] == token].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    cell_value = df.iloc[row_index[0], column_index]
    return cell_value


def clear_Token_History():
    try:
        os.remove("multiTokenHistory.csv")
        print(" multiTokenHistory.csv deleted successfully.")
    except FileNotFoundError:
        print("File multiTokenHistory.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")
        pass

def filter_multi_trade(column_name, match_string):
    df = multiTokenHistory()
    
    # Check if the column exists in the DataFrame
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")
    
    # Filter the DataFrame
    filtered_df = df[df[column_name] == match_string]
    
    # Reset the index of the filtered DataFrame
    filtered_df = filtered_df.reset_index(drop=True)
    
    return filtered_df

def add_token_history(sym, cprice, TCMF,TRSI,TMACD):
    dataframe=multiTokenHistory()
    new_row = pd.DataFrame({
        'token': sym,
        'price': cprice,
        'CMF': TCMF,
        'RSI': TRSI,
        'MACD': TMACD
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv("multiTokenHistory.csv", index=False)    
########################database##############

###############Logic###################

def bot_limited_Tokens(dictionary, n):
    new_dict = {}
    count = 0
    for key, value in dictionary.items():
        if count < n:
            new_dict[key] = value
            count += 1
        else:
            break
    return new_dict


def percentage_change(old_price, new_price):
    """
    Calculates and prints the percentage change between old_price and new_price.

    Parameters:
    old_price (float): The initial price.
    new_price (float): The new price.

    Returns:
    float: The percentage change between old_price and new_price.
    """
    if old_price == 0:
        raise ValueError("Old price cannot be zero")
    
    # Calculate the percentage change
    change = ((new_price - old_price) / old_price) * 100
    
    return abs(round(change,0))

def Evaluate_Trades():
    TLog=TradeLog()
    for index,item in TLog.iterrows():
        the_token=item['token']
        trade_type=item['type']
        trade_result=item['result']
        tokenhistory=filter_multi_trade('token', the_token)
        row_with_smallest_value = tokenhistory['price'].idxmin()
        row_with_largest_value = tokenhistory['price'].idxmax()
        sprice=tokenhistory.iloc[row_with_smallest_value]['price']
        lprice=tokenhistory.iloc[row_with_largest_value]['price']
        print(row_with_largest_value, row_with_smallest_value)
        price_change=percentage_change(sprice, lprice)
        print('price change in perecentage:',price_change)
        weight=round(price_change/100,2)
        if trade_result=="L":
            add_open_weight(weight,weight,weight,trade_type)
            add_close_weight(weight,weight,weight,trade_type)
        if trade_result=="W":
            sub_open_weight(weight,weight,weight,trade_type)
            sub_close_weight(weight,weight,weight,trade_type)
                 
        TCMF_o=tokenhistory.iloc[row_with_smallest_value]['CMF']
        TRSI_o=tokenhistory.iloc[row_with_smallest_value]['RSI']
        TMACD_o=tokenhistory.iloc[row_with_smallest_value]['MACD']
        
        TCMF_c=tokenhistory.iloc[row_with_largest_value]['CMF']
        TRSI_c=tokenhistory.iloc[row_with_largest_value]['RSI']
        TMACD_c=tokenhistory.iloc[row_with_largest_value]['MACD']

        print(TCMF_o,TRSI_o,TMACD_o,TCMF_c,TRSI_c,TMACD_c,'ref')
        updatereflections(TCMF_o,TRSI_o,TMACD_o,TCMF_c,TRSI_c,TMACD_c,'ref')
            
                
def add_open_weight(rsi_adj,cmf_adj,macd_adj,trade_type):
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
    rsi_w=[round(rsi_w[0] + rsi_adj, 2),rsi_w[1]]
    cmf_w=[round(cmf_w[0] + cmf_adj, 2),cmf_w[1]]
    macd_w=[round(macd_w[0] + macd_adj, 2),macd_w[1]]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','MACD', trade_type, macd_w)
    
def add_close_weight(rsi_adj,cmf_adj,macd_adj,trade_type):
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
    rsi_w=[rsi_w[0] , round(rsi_w[1] + rsi_adj, 2)]
    cmf_w=[cmf_w[0] , round(cmf_w[1] + cmf_adj, 2)]
    macd_w=[macd_w[0] , round(macd_w[1] + macd_adj, 2)]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','MACD', trade_type, macd_w)
    
def sub_open_weight(rsi_adj,cmf_adj,macd_adj,trade_type):
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
    rsi_w=[round(rsi_w[0] - rsi_adj, 2),rsi_w[1]]
    cmf_w=[round(cmf_w[0] - cmf_adj, 2),cmf_w[1]]
    macd_w=[round(macd_w[0] - macd_adj, 2),macd_w[1]]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','MACD', trade_type, macd_w)
    
def sub_close_weight(rsi_adj,cmf_adj,macd_adj,trade_type):
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
    rsi_w=[rsi_w[0] , round(rsi_w[1] - rsi_adj, 2)]
    cmf_w=[cmf_w[0] , round(cmf_w[1] - cmf_adj, 2)]
    macd_w=[macd_w[0] , round(macd_w[1] - macd_adj, 2)]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','MACD', trade_type, macd_w)

def rebalance():
    t_types=['FL','FS','RL','RS']
    for trade_type in t_types:
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
        rsi_w=[neutralize(rsi_w[0]) , neutralize(rsi_w[1])]
        cmf_w=[neutralize(cmf_w[0]) , neutralize(cmf_w[1])]
        macd_w=[neutralize(macd_w[0]) , neutralize(macd_w[1])]
        update_cell_table('weights','CMF', trade_type, cmf_w)
        update_cell_table('weights','RSI', trade_type, rsi_w)
        update_cell_table('weights','MACD', trade_type, macd_w)
    
def neutralize(number):
    max_value=1
    min_value=0
    if min_value == max_value:
        raise ValueError("min_value and max_value cannot be the same")

    # Normalize the number
    normalized = (number - min_value) / (max_value - min_value)
    
    # Clamp the values to the range [0, 1]
    normalized_clamped = max(0, min(normalized, 1))

    return normalized_clamped

def running_average(previous_avg, new_number, total_items):
    if total_items == 0:
        return new_number
    else:
        return round((previous_avg * total_items + new_number) / (total_items + 1),2)
             
def updatereflections(TCMF_o,TRSI_o,TMACD_o,TCMF_c,TRSI_c,TMACD_c,ttype):
    base=6969
    range_rsi=ast.literal_eval(read_matching_table('reflections','RSI', ttype))
    range_cmf=ast.literal_eval(read_matching_table('reflections','CMF', ttype))
    range_macd=ast.literal_eval(read_matching_table('reflections','MACD', ttype))
    if range_rsi[0]==base:
        range_rsi=[0,range_rsi[1]]
    if range_rsi[1]==base:
        range_rsi=[range_rsi[0],0]
    if range_cmf[0]==base:
        range_cmf=[0,range_cmf[1]]
    if range_cmf[1]==base:
        range_cmf=[range_cmf[0],0]
    if range_macd[0]==base:
        range_macd=[0,range_macd[1]]
    if range_macd[1]==base:
        range_macd=[range_macd[0],0]
    TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', ttype))
    TNUM=TNUM + 1
    update_cell_table('reflections','TNUM', ttype, TNUM)
    TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', ttype))
    range_rsi=str([running_average(range_rsi[0], TRSI_o, TNUM),running_average(range_rsi[1], TRSI_c, TNUM)])
    range_cmf=str([running_average(range_cmf[0], TCMF_o, TNUM),running_average(range_cmf[1], TCMF_c, TNUM)])
    range_macd=str([running_average(range_macd[0], TMACD_o, TNUM),running_average(range_macd[1], TMACD_c, TNUM)])
    update_cell_table('reflections','RSI', ttype, range_rsi)
    update_cell_table('reflections','CMF', ttype, range_cmf)
    update_cell_table('reflections','MACD', ttype, range_macd)

    
def trigger_amount(trade_type,side):
    if side=='open':
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
        return round(((cmf_w[0]+rsi_w[0]+macd_w[0])/3),2)
    if side=='close':
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        macd_w=ast.literal_eval(read_matching_table('weights','MACD', trade_type))
        return round(((cmf_w[1]+rsi_w[1]+macd_w[1])/3),2)
    
def adjust_range(range_list, number, direction):
    range_start, range_end = range_list
    range_size = range_end - range_start
    
    if direction == 'up':
        new_range_start = number
        new_range_end = new_range_start + range_size
    elif direction == 'down':
        new_range_end = number
        new_range_start = new_range_end - range_size
    else:
        raise ValueError("Direction must be either 'up' or 'down'")
    
    return [round(new_range_start, 2), round(new_range_end, 2)]

def adjust_and_reflect():
    empty=6969
    t_types=['FL','FS','RL','RS']
    rsi_dif=[0,10]
    macd_dif=[0,10]
    cmf_dif=[0,0.5]
    for trade_type in t_types:
        
        ref_rsi=ast.literal_eval(read_matching_table('reflections','RSI', 'ref'))
        ref_macd=ast.literal_eval(read_matching_table('reflections','MACD', 'ref'))
        ref_cmf=ast.literal_eval(read_matching_table('reflections','CMF', 'ref'))
        if trade_type=='FL':
            spin='up'
            open_rsi=ref_rsi[1]
            open_cmf=ref_cmf[1]
            open_macd=ref_macd[1]
            close_rsi=ref_rsi[0]
            close_cmf=ref_cmf[0]
            close_macd=ref_macd[0]
        if trade_type=='FS':
            spin='up'
            open_rsi=ref_rsi[0]
            open_cmf=ref_cmf[0]
            open_macd=ref_macd[0]
            close_rsi=ref_rsi[1]
            close_cmf=ref_cmf[1]
            close_macd=ref_macd[1]
        if trade_type=='RL':
            spin='down'
            open_rsi=ref_rsi[0]
            open_cmf=ref_cmf[0]
            open_macd=ref_macd[0]
            close_rsi=ref_rsi[1]
            close_cmf=ref_cmf[1]
            close_macd=ref_macd[1]
        if trade_type=='RS':
            spin='down'
            open_rsi=ref_rsi[1]
            open_cmf=ref_cmf[1]
            open_macd=ref_macd[1]
            close_rsi=ref_rsi[0]
            close_cmf=ref_cmf[0]
            close_macd=ref_macd[0]

        if open_rsi!=empty and close_rsi!=empty:
            on_rsi=adjust_range(rsi_dif,open_rsi,spin)
            cn_rsi=adjust_range(rsi_dif,close_rsi,spin)
            new_range=str([on_rsi,cn_rsi])
            update_cell_table('nodes','RSI', trade_type, new_range)

        if open_macd!=empty and close_macd!=empty:
            on_macd=adjust_range(macd_dif,open_macd,spin)
            cn_macd=adjust_range(macd_dif,close_macd,spin)
            new_range=str([on_macd,cn_macd])
            update_cell_table('nodes','MACD', trade_type, new_range)
                            
        if open_cmf!=empty and close_cmf!=empty:
            on_cmf=adjust_range(cmf_dif,open_cmf,spin)
            cn_cmf=adjust_range(cmf_dif,close_cmf,spin)
            new_range=str([on_cmf,cn_cmf])
            update_cell_table('nodes','CMF', trade_type, new_range)
              
def all_w_or_l(column_name, df):
    # Check if the column exists in the DataFrame
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")
    
    # Check if all values in the column are either 'W' or 'L'
    if (df[column_name].isin(['W', 'L'])).all():
        return True
    else:
        return False
    
######### Real Trading #############
def realtrade(bList,BotLimit,lvrg,tinfo):
    client = Client(api_key, api_secret)
    mrgType="ISOLATED"
    for Ti,ttype in bList.items():
        Lsafe(client, Ti, mrgType, lvrg)
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="FL" or ttype=="RL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=LongOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,'A',p,ttype)
        if  ttype=="FS" or ttype=="RS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=ShortOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,'A',p,ttype)
        sleep(5)
    while True:
        TLog=TradeLog()
        for x in range(len(TLog)):
            ttype=TLog.iloc[x]['type']
            svresult=TLog.iloc[x]['result']
            Ti=TLog.iloc[x]['token']
            status=TLog.iloc[x]['status']
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TRSI=rsi(df)
            TMACD=MACD(df)
            amount=read_matching_TLog(Ti, 'amount')
            cprice = df['close'].iloc[-1]
            oprice=read_matching_TLog(Ti, 'opprice')
            add_token_history(Ti,cprice,TCMF,TRSI,TMACD)
            if svresult!='W' and svresult!='L':
                if status=='RS':
                    if oprice>cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'status', 'FS')
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeShort(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if status=='RL':
                    if oprice<cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'status', 'FL')
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeLong(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                        
                if status=='FL':   
                    if oprice<cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeLong(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'W')
                            print("trade closed : ", Ti)
                            break
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeLong(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if status=='FS':   
                    if oprice>cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeShort(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'W')
                            print("trade closed : ", Ti)
                            break
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            closeShort(client,amount,Ti)
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
        TLog=TradeLog()
        if all_w_or_l('result', TLog):
            print("All Trades Done")
            return True
        sleep(300)
    print("All Trades Done")
    return True

#############Logic####################
def simtrade(bList,BotLimit,tinfo):
    client = Client(api_key, api_secret)
    for Ti,ttype in bList.items():
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="FL" or ttype=="RL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'A','0',ttype)
        if ttype=="RS" or ttype=="FS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'A','0',ttype)
    while True:
        TLog=TradeLog()
        for x in range(len(TLog)):
            ttype=TLog.iloc[x]['type']
            svresult=TLog.iloc[x]['result']
            Ti=TLog.iloc[x]['token']
            status=TLog.iloc[x]['status']
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TRSI=rsi(df)
            TMACD=MACD(df)
            cprice = df['close'].iloc[-1]
            oprice=read_matching_TLog(Ti, 'opprice')
            add_token_history(Ti, cprice,TCMF,TRSI,TMACD)
            print(Ti, cprice,TCMF,TRSI,TMACD)
            #i learned something new about if statements
            if svresult!='W' and svresult!='L':
                if status=='RS':
                    if oprice>cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            print("flipped to FS")
                            update_cell_Tlog(Ti, 'status', 'FS')
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if status=='RL':
                    if oprice<cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            print("flipped to FL")
                            update_cell_Tlog(Ti, 'status', 'FL')
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if status=='FL':   
                    if oprice<cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'W')
                            print("trade closed : ", Ti)
                            break
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if status=='FS':   
                    if oprice>cprice:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'W')
                            print("trade closed : ", Ti)
                            break
                    else:
                        close_intensity=is_between_close(TRSI,TCMF,TMACD,status)
                        if close_intensity>trigger_amount(status,'close'):
                            update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
        TLog=TradeLog()
        if all_w_or_l('result', TLog):
            print("All Trades Done")
            return True
        sleep(300)
    print("All Trades Done")
    return True
        
########trainer############
def main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial):
    client = Client(api_key, api_secret)
    while True:
        balance = client.futures_account_balance()
        bal = None
        for wc in balance:
            if wc["asset"] == 'USDT':
                bal = float(wc["balance"])
        if bal > initial:
            amnt = bal - initial
            client.futures_account_transfer(asset='USDT', amount=amnt, Type=2)
            print("Profit Transfer:", amnt)
        if bal > 50:
            BotLimit=4
        if bal > 100:
            BotLimit=5
        if bal > 500:
            BotLimit=7
        if bal > 900:
            BotLimit=10
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=realtrade(botLimit_tokens,BotLimit,lvrg,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                adjust_and_reflect()
                rebalance()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

def simulated_trader(excludedlist,CurrencyType,BotLimit):
    while True:
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=simtrade(botLimit_tokens,BotLimit,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                adjust_and_reflect()
                rebalance()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

#clear_tradeLog()
#clear_Token_History()  
BotLimit=3
print("Booting up... ")
excludedlist=['BTCUSDT','BTCDOMUSDT','USDCUSDT']
CurrencyType="USDT"
lvrg=2
initial_amt=1000
main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial_amt)
#simulated_trader(excludedlist,CurrencyType,BotLimit)
#Evaluate_Trades()
#adjust_and_reflect()
#rebalance()
#the length of token history should determine the weight 
#its learning flipped
#somthing that takes percentage and a range as input and moves that range towards a given number by that  percent
# the percentage can end up being negative because weights are added when you win a trade and the percentage is higher than 1
