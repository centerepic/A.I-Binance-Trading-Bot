# -*- coding: utf-8 -*-
"""
Created on Mon Jan  8 06:16:20 2024

@author: azzy
"""
from keys import *
# importing keys
import multiprocessing
import pandas as pd
import numpy as np #computing multidimensionla arrays
from datetime import datetime
from time import sleep
from binance.client import Client
from binance import *
from binance.enums import *
import math
import pandas_ta as ta
import operator
import os
import sys
import ast
globalInterval=Client.KLINE_INTERVAL_5MINUTE
########close/open trades###########
def Lsafe(client,Seed,mrgType,lvrg):
    try:
        client.futures_change_leverage(symbol=Seed,leverage=lvrg)
        client.futures_change_margin_type(symbol=Seed,marginType=mrgType)
    except:
        return
    
#Precession
def get_current_datetime_as_string():
    current_datetime = datetime.now()
    return current_datetime.strftime("%Y-%m-%d %H:%M:%S")

def truncate(number, precision):
    factor = 10.0 ** precision
    return int(number * factor) / factor

def LongOrder(client, Seed, precision, numBots, lvrg):
    balance = client.futures_account_balance()
    bal = None
    
    for wc in balance:
        if wc["asset"] == 'USDT':
            bal = float(wc["balance"])
            break

    if bal is None:
        return "No USDT balance found"

    percent = 1 / numBots  # Calculate the percentage of balance to use for each bot

    price = float(client.futures_mark_price(symbol=Seed)["markPrice"])
    maxl = (bal * percent) * lvrg
    maxq = maxl / price
    q = truncate(maxq, precision)

    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_BUY, quantity=str(q))
        return str(q)
    except:
        return "null"

def ShortOrder(client, Seed, precision, numBots, lvrg):
    balance = client.futures_account_balance()
    bal = None
    
    for wc in balance:
        if wc["asset"] == 'USDT':
            bal = float(wc["balance"])
            break

    if bal is None:
        return "No USDT balance found"

    percent = 1 / numBots  # Calculate the percentage of balance to use for each bot

    price = float(client.futures_mark_price(symbol=Seed)["markPrice"])
    maxl = (bal * percent) * lvrg
    maxq = maxl / price
    q = truncate(maxq, precision)

    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_SELL, quantity=str(q))
        return str(q)
    except:
        return "null"

def closeLong(client, p, Seed):
    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_SELL, quantity=p, reduceOnly='true')
        return f"Closed long position with quantity {p}"
    except:
        return "null"

def closeShort(client, p, Seed):
    try:
        client.futures_create_order(symbol=Seed, type=ORDER_TYPE_MARKET, side=SIDE_BUY, quantity=p, reduceOnly='true')
        return f"Closed short position with quantity {p}"
    except:
        return "null"
    
########close/open trades###########

#################### Get token info #########################

def batchCollector(excludedlist,CurrencyType):
    client = Client(api_key, api_secret)
    exInfo=client.futures_exchange_info()
    tokenInf,sinf=FindNewToken(client,exInfo,excludedlist,CurrencyType)
    Ftoken_list=OpenLayer(tokenInf)
    return Ftoken_list,sinf

def TokenInfo(client,sym,CurrencyType):
    try:
        candles = client.futures_continous_klines(pair=sym, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        return df
    except Exception as e:
        #TokenInfo error Removed from Market or not added yet
        print("TokenInfo error Removed from Market or not added yet",e)

def FindNewToken(client,exInfo,excludedlist,CurrencyType):
    symInfo={}
    tokenInfo={}
    for symbol in exInfo["symbols"]:
        if symbol["contractType"]=="PERPETUAL" and symbol["symbol"] not in excludedlist and CurrencyType in symbol["symbol"] and symbol["status"]=="TRADING":
            symInfo[symbol["symbol"]]=symbol["quantityPrecision"]
    x=0
    for key,values in symInfo.items():
        result=TokenInfo(client,key,CurrencyType)
        tokenInfo[key]=result
        if x==30:
            print("30%")
        if x==80:
            print("80%")
        if x==130:
            print("99%")
        x+=1
    print('100%')            
    return tokenInfo,symInfo

def OpenLayer(TokenInfo):
    ranked_result={}
    trade_types=['GL','GS','TL','TS']
    for Ti,value in TokenInfo.items():
        pressurelist={}
        try:
            TZSCORE=zscore(value)
            TCMF=CMF(value)
            TTREND=super_trend(value)
            TRSI=rsi(value)
            for ttype in trade_types:
                range_intensity=is_between_open(TRSI,TCMF,TTREND,ttype)
                pressurelist[ttype]=round((range_intensity+abs(TZSCORE)),2)
        except Exception as e:
            #TokenInfo error Removed from Market or not added yet
            print("TokenInfo error Removed from Market or not added yet",e)
        bestchoice=get_key_of_higher_number(pressurelist)
        if bestchoice !=None:
            if pressurelist[bestchoice]>trigger_amount(bestchoice,'open'):
                ranked_result[Ti]=[pressurelist[bestchoice],bestchoice]
    # Sort the keys based on the first element of the list in descending order
    sorted_keys = sorted(ranked_result.keys(), key=lambda x: ranked_result[x][0], reverse=True)
    # Reorganize the dictionary using the sorted keys
    sorted_ranked_result = {key: ranked_result[key] for key in sorted_keys}
    Tresult={}
    for key,item in sorted_ranked_result.items():
        Tresult[key]=item[1]
    return Tresult

def get_key_of_higher_number(dictionary):
    # Initialize variables to keep track of the highest number and its corresponding key
    highest_number = float('-inf')  # Start with a very low number
    highest_key = None

    # Iterate through the dictionary
    for key, value in dictionary.items():
        # If the current value is higher than the highest number found so far
        if value > highest_number:
            highest_number = value
            highest_key = key
    # Return the key corresponding to the highest number
    return highest_key


def CloseLayer(TRSI,TCMF,TTREND,ttype):
    edge_intensity=is_between_close(TRSI,TCMF,TTREND,ttype)
    trigger=trigger_amount(ttype,'close')
    if edge_intensity>trigger:
        return True,edge_intensity
    else:
        return False,edge_intensity
#problem rippling solution
def is_between_open(TRSI,TCMF,TTREND,ttype):
    range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[0]
    range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[0]
    trend=ast.literal_eval(read_matching_table('nodes','TREND', ttype))[0]
    RSI_intensity= intensity_from_mid(TRSI, range_rsi[0], range_rsi[1])
    CMF_intensity= intensity_from_mid(TCMF, range_cmf[0], range_cmf[1])
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', ttype))[0]
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[0]
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[0]
    average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + (trend_w * trend)),2)
    return average

def is_between_close(TRSI,TCMF,TTREND,ttype):
    range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[1]
    range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[1]
    trend=ast.literal_eval(read_matching_table('nodes','TREND', ttype))[1]
    RSI_intensity= intensity_from_mid(TRSI, range_rsi[0], range_rsi[1])
    CMF_intensity= intensity_from_mid(TCMF, range_cmf[0], range_cmf[1])
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', ttype))[1]
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[1]
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[1]
    average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + (trend_w * trend)),2)
    return average

#################### Get token info #########################

############# Indicators #############
def super_trend(df, period=7, multiplier=3.0):
    supertrend = df.ta.supertrend(high='high', low='low', close='close', length=period, multiplier=multiplier)
    df = pd.concat([df, supertrend], axis=1)
    latest_trend = 1 if df.iloc[-1]['close'] > df.iloc[-1]['SUPERT_'+str(period)+"_"+str(multiplier)] else 0
    return latest_trend

def CMF(data):
    period = 20
    mf = ((data['close'] - data['low']) - (data['high'] - data['close'])) / (data['high'] - data['low'])
    mfv = mf * data['volume']
    cmf_values = mfv.rolling(period).sum() / data['volume'].rolling(period).sum()
    cmf_values = cmf_values.dropna() 
    return round(cmf_values.iloc[-1],2)

def rsi(dataset):
    S=dataset.ta.rsi(length=14)
    rssi=round(S.iloc[-1],2)
    return rssi

def zscore(dataset):
    zpoints=dataset.ta.zscore().dropna()
    zscore=round(zpoints.iloc[-1],2)
    return zscore


def intensity_from_edge(number, range_start, range_end):
    # Sort the range automatically
    sorted_range = sorted([range_start, range_end])
    range_start, range_end = sorted_range[0], sorted_range[1]

    if range_start == range_end:
        raise ValueError("Range start and end cannot be the same.")
    
    if not (range_start <= number <= range_end):
        return 0  # If the number is out of the specified range, intensity is 0.

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Calculate the distance of the number from the midpoint
    distance_from_midpoint = abs(number - midpoint)

    # Calculate the maximum distance from the midpoint (half the absolute range)
    max_distance = abs(range_end - range_start) / 2

    # Calculate the intensity based on the distance from the midpoint
    # Adjust the calculation to give a higher intensity when further away from the midpoint
    intensity = 1 - (distance_from_midpoint / max_distance)
    # Change the intensity to be higher when closer to the midpoint
    intensity = 1 - intensity

    return intensity

def intensity_from_mid(number, range_start, range_end):
    # Sort the range automatically
    sorted_range = sorted([range_start, range_end])
    range_start, range_end = sorted_range[0], sorted_range[1]

    if range_start == range_end:
        raise ValueError("Range start and end cannot be the same.")
    
    if not (range_start <= number <= range_end):
        return 0  # If the number is out of the specified range, intensity is 0.

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Calculate the distance of the number from the midpoint
    distance_from_midpoint = abs(number - midpoint)

    # Calculate the maximum distance from the midpoint (half the absolute range)
    max_distance = abs(range_end - range_start) / 2

    # Calculate the intensity based on the distance from the midpoint
    intensity = 1 - (distance_from_midpoint / max_distance)

    return intensity

############# Indicators #############
########################database##############

def nodes():
    if not os.path.exists('nodes.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI', 'CMF','TREND'],
            'GL': ['[[30,35],[65,70]]', '[[-0.2,0],[0,0.2]]','[0,1]'],
            'GS': ['[[65,70],[30,35]]', '[[0,0.2],[-0.2,0]]','[1,0]'],
            'TL': ['[[70,75],[30,25]]', '[[0.2,0.5],[-0.5,-0.2]]','[1,0]'],
            'TS': ['[[30,25],[70,75]]', '[[-0.5,-0.2],[0.2,0.5]]','[0,1]']
            }
        df = pd.DataFrame(data)
        df.to_csv('nodes.csv', index=False)
        return df
    else:
        df=pd.read_csv('nodes.csv')
        return df
def reflections():
    if not os.path.exists('reflections.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI','CMF','TREND','TNUM'],
            'GL': ['[6969,6969]','[6969,6969]', '[6969,6969]','0'],
            'GS': ['[6969,6969]','[6969,6969]', '[6969,6969]','0'],
            'TL': ['[6969,6969]','[6969,6969]','[6969,6969]','0'],
            'TS': ['[6969,6969]','[6969,6969]', '[6969,6969]','0']
            }
        df = pd.DataFrame(data)
        df.to_csv('reflections.csv', index=False)
        return df
    else:
        df=pd.read_csv('reflections.csv')
        return df
def weights():
    if not os.path.exists('weights.csv'):
        # Create a DataFrame with the desired structure '[1,1]', '[1,1]', '[1,1]', '[1,1]',
        data = {
            'IND': ['RSI', 'CMF', 'TREND'],
            'GL': ['[1,1]', '[1,1]','[1,1]'],
            'GS': ['[1,1]', '[1,1]','[1,1]'],
            'TL': ['[1,1]', '[1,1]', '[1,1]'],
            'TS': ['[1,1]', '[1,1]', '[1,1]']
            }
        df = pd.DataFrame(data)
        df.to_csv('weights.csv', index=False)
        return df
    else:
        df=pd.read_csv('weights.csv')
        return df
    
def read_matching_table(table,indicator, column_name):
    if table=='nodes':   
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    
def update_cell_table(table,indicator, column_name, new_value):
    if table=='nodes':
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('nodes.csv', index=False)
        return True
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('weights.csv', index=False)
        return True
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('reflections.csv', index=False)
        return True

def multiTokenHistory():
    if not os.path.exists('multiTokenHistory.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'price': [],
            'CMF': [],
            'RSI': [],
            'TREND': []
        }
        df = pd.DataFrame(data)
        df.to_csv('multiTokenHistory.csv', index=False)
        return df
    else:
        df=pd.read_csv('multiTokenHistory.csv')
        return df

def TradeLog():
    if not os.path.exists('TradeLog.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'type': [],
            'datetime': [],
            'opprice': [],
            'result':[]
        }
        df = pd.DataFrame(data)
        df.to_csv('TradeLog.csv', index=False)
        return df
    else:
        df=pd.read_csv('TradeLog.csv')
        return df

def clear_tradeLog():
    try:
        os.remove("TradeLog.csv")
        print(" TradeLog.csv deleted successfully.")
    except FileNotFoundError:
        print("File TradeLog.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")

def add_tradeLog(Ti, ttype, datetime, opprice,result,amount):
    dataframe=TradeLog()
    new_row = pd.DataFrame({
        'token': Ti,
        'type': ttype,
        'datetime': datetime,
        'opprice': opprice,
        'amount': amount,
        'result': result
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv('TradeLog.csv', index=False)
    
def update_cell_Tlog(token, column_name, new_value):
    df=TradeLog()
    row_index = df.index[df['token'] == token ].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    df.iloc[row_index[0], column_index] = new_value
    df.to_csv('TradeLog.csv', index=False)
    return True

def read_matching_TLog(token, column_name):
    df=TradeLog()
    row_index = df.index[df['token'] == token].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    cell_value = df.iloc[row_index[0], column_index]
    return cell_value


def clear_Token_History():
    try:
        os.remove("multiTokenHistory.csv")
        print(" multiTokenHistory.csv deleted successfully.")
    except FileNotFoundError:
        print("File multiTokenHistory.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")
        pass

def filter_multi_trade(column_name, match_string):
    df = multiTokenHistory()
    
    # Check if the column exists in the DataFrame
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")
    
    # Filter the DataFrame
    filtered_df = df[df[column_name] == match_string]
    
    # Reset the index of the filtered DataFrame
    filtered_df = filtered_df.reset_index(drop=True)
    
    return filtered_df

def add_token_history(sym, cprice, TCMF, TRSI, TTREND):
    dataframe=multiTokenHistory()
    new_row = pd.DataFrame({
        'token': sym,
        'price': cprice,
        'CMF': TCMF,
        'RSI': TRSI,
        'TREND': TTREND
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv("multiTokenHistory.csv", index=False)    
########################database##############

###############Logic###################

def bot_limited_Tokens(dictionary, n):
    new_dict = {}
    count = 0
    for key, value in dictionary.items():
        if count < n:
            new_dict[key] = value
            count += 1
        else:
            break
    return new_dict

def angle_to_normalized_value(num1, num2):
    # Calculate the absolute rise
    rise = abs(num2 - num1)
    
    # Calculate the run (use 1 to represent a unit horizontal distance)
    run = 1
    
    # Calculate the angle in radians
    angle_radians = math.atan2(rise, run)
    
    # Convert the angle to degrees
    angle_degrees = math.degrees(angle_radians)
    
    # Normalize the angle to the range [0, 1], where 90 degrees is 1
    normalized_value = angle_degrees / 90
    
    # Ensure the value is within the range [0, 1]
    normalized_value = min(max(normalized_value, 0), 1)
    
    return round(normalized_value,2)
    
def Evaluate_Trades():
    TLog=TradeLog()
    for index,item in TLog.iterrows():
        the_token=item['token']
        trade_type=item['type']
        trade_result=item['result']
        tokenhistory=filter_multi_trade('token', the_token)
        row_with_smallest_value = tokenhistory['price'].idxmin()
        row_with_largest_value = tokenhistory['price'].idxmax()
        print(row_with_largest_value, row_with_smallest_value)
        if trade_result=="L":
            if row_with_smallest_value<row_with_largest_value:
                TCMF_o=tokenhistory.iloc[row_with_smallest_value]['CMF']
                TTREND_o=tokenhistory.iloc[row_with_smallest_value]['TREND']
                TRSI_o=tokenhistory.iloc[row_with_smallest_value]['RSI']
                TCMF_oo=tokenhistory.iloc[row_with_smallest_value + 1]['CMF']
                TTREND_oo=tokenhistory.iloc[row_with_smallest_value + 1]['TREND']
                TRSI_oo=tokenhistory.iloc[row_with_smallest_value + 1]['RSI']
                
                TCMF_c=tokenhistory.iloc[row_with_largest_value]['CMF']
                TTREND_c=tokenhistory.iloc[row_with_largest_value]['TREND']
                TRSI_c=tokenhistory.iloc[row_with_largest_value]['RSI']
                TCMF_cc=tokenhistory.iloc[row_with_largest_value - 1]['CMF']
                TTREND_cc=tokenhistory.iloc[row_with_largest_value - 1]['TREND']
                TRSI_cc=tokenhistory.iloc[row_with_largest_value - 1]['RSI']
                
                rsi_adj=angle_to_normalized_value(TRSI_o, TRSI_oo)
                cmf_adj=angle_to_normalized_value(TCMF_o, TCMF_oo)
                trend_adj=angle_to_normalized_value(TTREND_o, TTREND_oo)
                
                sub_open_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
                
                rsi_adj=angle_to_normalized_value(TRSI_c, TRSI_cc)
                cmf_adj=angle_to_normalized_value(TCMF_c, TCMF_cc)
                trend_adj=angle_to_normalized_value(TTREND_c, TTREND_cc)
                
                sub_close_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
                
                print(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GL')
                updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GL')
                print(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TL')
                updatereflections(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TL')
            else:

                TCMF_o=tokenhistory.iloc[row_with_largest_value]['CMF']
                TTREND_o=tokenhistory.iloc[row_with_largest_value]['TREND']
                TRSI_o=tokenhistory.iloc[row_with_largest_value]['RSI']
                TCMF_oo=tokenhistory.iloc[row_with_largest_value + 1]['CMF']
                TTREND_oo=tokenhistory.iloc[row_with_largest_value + 1]['TREND']
                TRSI_oo=tokenhistory.iloc[row_with_largest_value + 1]['RSI']
                TCMF_c=tokenhistory.iloc[row_with_smallest_value]['CMF']
                TTREND_c=tokenhistory.iloc[row_with_smallest_value]['TREND']
                TRSI_c=tokenhistory.iloc[row_with_smallest_value]['RSI']
                TCMF_cc=tokenhistory.iloc[row_with_smallest_value - 1]['CMF']
                TTREND_cc=tokenhistory.iloc[row_with_smallest_value - 1]['TREND']
                TRSI_cc=tokenhistory.iloc[row_with_smallest_value - 1]['RSI']
                
                rsi_adj=angle_to_normalized_value(TRSI_o, TRSI_oo)
                cmf_adj=angle_to_normalized_value(TCMF_o, TCMF_oo)
                trend_adj=angle_to_normalized_value(TTREND_o, TTREND_oo)
                
                sub_open_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
                
                rsi_adj=angle_to_normalized_value(TRSI_c, TRSI_cc)
                cmf_adj=angle_to_normalized_value(TCMF_c, TCMF_cc)
                trend_adj=angle_to_normalized_value(TTREND_c, TTREND_cc)
                
                sub_close_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
                
                print(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GS')
                updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GS')
                print(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TS')
                updatereflections(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TS')
        else:
            TCMF_o = tokenhistory.iloc[0]['CMF']
            TTREND_o = tokenhistory.iloc[0]['TREND']
            TRSI_o = tokenhistory.iloc[0]['RSI']
            TCMF_oo = tokenhistory.iloc[1]['CMF']
            TTREND_oo = tokenhistory.iloc[1]['TREND']
            TRSI_oo = tokenhistory.iloc[1]['RSI']
            
            TCMF_c = tokenhistory.iloc[-1]['CMF']
            TTREND_c = tokenhistory.iloc[-1]['TREND']
            TRSI_c = tokenhistory.iloc[-1]['RSI']
            TCMF_cc = tokenhistory.iloc[-2]['CMF']
            TTREND_cc = tokenhistory.iloc[-2]['TREND']
            TRSI_cc = tokenhistory.iloc[-2]['RSI']
                
            rsi_adj=round(angle_to_normalized_value(TRSI_o, TRSI_oo)/2,2)
            cmf_adj=round(angle_to_normalized_value(TCMF_o, TCMF_oo)/2,2)
            trend_adj=round(angle_to_normalized_value(TTREND_o, TTREND_oo)/2,2)
            add_open_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
            
            rsi_adj=round(angle_to_normalized_value(TRSI_c, TRSI_cc)/2,2)
            cmf_adj=round(angle_to_normalized_value(TCMF_c, TCMF_cc)/2,2)
            trend_adj=round(angle_to_normalized_value(TTREND_c, TTREND_cc)/2,2)
            add_close_weight(rsi_adj,cmf_adj,trend_adj,trade_type)
            
            updatereflections(TCMF_oo,TRSI_oo,TTREND_oo,TCMF_cc,TTREND_cc,TRSI_cc,trade_type)
            
            if row_with_smallest_value<row_with_largest_value:
                TCMF_o=tokenhistory.iloc[row_with_smallest_value]['CMF']
                TTREND_o=tokenhistory.iloc[row_with_smallest_value]['TREND']
                TRSI_o=tokenhistory.iloc[row_with_smallest_value]['RSI']
                TCMF_oo=tokenhistory.iloc[row_with_smallest_value + 1]['CMF']
                TTREND_oo=tokenhistory.iloc[row_with_smallest_value + 1]['TREND']
                TRSI_oo=tokenhistory.iloc[row_with_smallest_value + 1]['RSI']
                
                TCMF_c=tokenhistory.iloc[row_with_largest_value]['CMF']
                TTREND_c=tokenhistory.iloc[row_with_largest_value]['TREND']
                TRSI_c=tokenhistory.iloc[row_with_largest_value]['RSI']
                TCMF_cc=tokenhistory.iloc[row_with_largest_value - 1]['CMF']
                TTREND_cc=tokenhistory.iloc[row_with_largest_value - 1]['TREND']
                TRSI_cc=tokenhistory.iloc[row_with_largest_value - 1]['RSI']
                
                print(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GL')
                updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GL')
                print(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TL')
                updatereflections(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TL')
            else:
                TCMF_o=tokenhistory.iloc[row_with_largest_value]['CMF']
                TTREND_o=tokenhistory.iloc[row_with_largest_value]['TREND']
                TRSI_o=tokenhistory.iloc[row_with_largest_value]['RSI']
                TCMF_oo=tokenhistory.iloc[row_with_largest_value + 1]['CMF']
                TTREND_oo=tokenhistory.iloc[row_with_largest_value + 1]['TREND']
                TRSI_oo=tokenhistory.iloc[row_with_largest_value + 1]['RSI']
                TCMF_c=tokenhistory.iloc[row_with_smallest_value]['CMF']
                TTREND_c=tokenhistory.iloc[row_with_smallest_value]['TREND']
                TRSI_c=tokenhistory.iloc[row_with_smallest_value]['RSI']
                TCMF_cc=tokenhistory.iloc[row_with_smallest_value - 1]['CMF']
                TTREND_cc=tokenhistory.iloc[row_with_smallest_value - 1]['TREND']
                TRSI_cc=tokenhistory.iloc[row_with_smallest_value - 1]['RSI']
                
                print(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GS')
                updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,'GS')
                print(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TS')
                updatereflections(TCMF_cc,TRSI_cc,TTREND_cc,TCMF_oo,TTREND_oo,TRSI_oo,'TS')
                
def add_open_weight(rsi_adj,cmf_adj,trend_adj,trade_type):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w=[round(trend_w[0] + trend_adj, 2),trend_w[1]]
    rsi_w=[round(rsi_w[0] + rsi_adj, 2),rsi_w[1]]
    cmf_w=[round(cmf_w[0] + cmf_adj, 2),cmf_w[1]]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    
def add_close_weight(rsi_adj,cmf_adj,trend_adj,trade_type):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w=[trend_w[0] , round(trend_w[1] + trend_adj, 2)]
    rsi_w=[rsi_w[0] , round(rsi_w[1] + rsi_adj, 2)]
    cmf_w=[cmf_w[0] , round(cmf_w[1] + cmf_adj, 2)]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    
def sub_open_weight(rsi_adj,cmf_adj,trend_adj,trade_type):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w=[round(trend_w[0] - trend_adj, 2),trend_w[1]]
    rsi_w=[round(rsi_w[0] - rsi_adj, 2),rsi_w[1]]
    cmf_w=[round(cmf_w[0] - cmf_adj, 2),cmf_w[1]]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    
def sub_close_weight(rsi_adj,cmf_adj,trend_adj,trade_type):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w=[trend_w[0] , round(trend_w[1] - trend_adj, 2)]
    rsi_w=[rsi_w[0] , round(rsi_w[1] - rsi_adj, 2)]
    cmf_w=[cmf_w[0] , round(cmf_w[1] - cmf_adj, 2)]
    update_cell_table('weights','CMF', trade_type, cmf_w)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
        
def running_average(previous_avg, new_number, total_items):
    if total_items == 0:
        return new_number
    else:
        return (previous_avg * total_items + new_number) / (total_items + 1)  
             
def updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,ttype):
    base=6969
    range_rsi=ast.literal_eval(read_matching_table('reflections','RSI', ttype))
    range_cmf=ast.literal_eval(read_matching_table('reflections','CMF', ttype))
    trend=ast.literal_eval(read_matching_table('reflections','TREND', ttype))
    TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', ttype))
    if range_rsi[0]==base:
        range_rsi=[0,range_rsi[1]]
    if range_rsi[1]==base:
        range_rsi=[range_rsi[0],0]
    if range_cmf[0]==base:
        range_cmf=[0,range_cmf[1]]
    if range_cmf[1]==base:
        range_cmf=[range_cmf[0],0]
    if trend[0]==base:
        trend=[0,trend[1]]
    if trend[1]==base:
        trend=[trend[0],0]   
    range_rsi=str([round(running_average(range_rsi[0], TRSI_o, TNUM),2),round(running_average(range_rsi[1], TRSI_c, TNUM),2)])
    range_cmf=str([round(running_average(range_cmf[0], TCMF_o, TNUM),2),round(running_average(range_cmf[1], TCMF_c, TNUM),2)])
    trend=str([round(running_average(trend[0], TTREND_o, TNUM),2),round(running_average(trend[1], TTREND_c, TNUM),2)])
    update_cell_table('reflections','RSI', ttype, range_rsi)
    update_cell_table('reflections','CMF', ttype, range_cmf)
    update_cell_table('reflections','TREND', ttype, trend)
    TNUM=TNUM + 1
    update_cell_table('reflections','TNUM', ttype, TNUM)
    
def trigger_amount(trade_type,side):
    if side=='open':
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        return round((trend_w[0]+cmf_w[0]+rsi_w[0])/3,2)
    if side=='close':
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        return round((trend_w[1]+cmf_w[1]+rsi_w[1])/3,2)

def adjust_and_reflect():
    empty=6969
    t_types=["GL","TL","GS","TS"]
    for trade_type in t_types:     
        range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', trade_type))
        ref_rsi=ast.literal_eval(read_matching_table('reflections','RSI', trade_type))   
        if ref_rsi[0]!=empty:
            new_range=str([adjust_range(range_rsi[0], ref_rsi[0]),range_rsi[1]])
            update_cell_table('nodes','RSI', trade_type, new_range)
            
        range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', trade_type))
        ref_rsi=ast.literal_eval(read_matching_table('reflections','RSI', trade_type))
        if ref_rsi[1]!=empty:
            new_range=str([range_rsi[0],adjust_range(range_rsi[1],ref_rsi[1])])
            update_cell_table('nodes','RSI', trade_type, new_range)
            
        range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', trade_type))
        ref_cmf=ast.literal_eval(read_matching_table('reflections','CMF', trade_type))
        if ref_cmf[0]!=empty:
            new_range=str([adjust_range(range_cmf[0], ref_cmf[0]),range_cmf[1]])
            update_cell_table('nodes','CMF', trade_type, new_range)
                
        range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', trade_type))
        ref_cmf=ast.literal_eval(read_matching_table('reflections','CMF', trade_type))
        if ref_cmf[1]!=empty:
            new_range=str([range_cmf[0],adjust_range(range_cmf[1], ref_cmf[1])])
            update_cell_table('nodes','CMF', trade_type, new_range)
            
        trend=ast.literal_eval(read_matching_table('nodes','TREND', trade_type))
        ref_trend=ast.literal_eval(read_matching_table('reflections','TREND', trade_type))
        if ref_trend[0]!=empty:
            if ref_trend[0]>0.5:
                new_range=str([1,trend[1]])
            else:
                new_range=str([0,trend[1]])
            update_cell_table('nodes','TREND', trade_type, new_range)
            
        trend=ast.literal_eval(read_matching_table('nodes','TREND', trade_type))
        ref_trend=ast.literal_eval(read_matching_table('reflections','TREND', trade_type))
        if ref_trend[1]!=empty:
            if ref_trend[1]>0.5:
                new_range=str([trend[0],1])
            else:
                new_range=str([trend[0],0])
            update_cell_table('nodes','TREND', trade_type, new_range)
                
def adjust_range(original_range, number):
    # Unpack the original range
    start, end = original_range
    
    # If number is 0, return the original range
    if number == 0:
        return original_range
    
    # Calculate the difference between end and start
    diff = end - start
    
    # If number is less than start, adjust the range
    if number < start:
        new_start = round(number,2)
        new_end = round((number + diff),2)
    # If number is greater than end, adjust the range
    elif number > end:
        new_start = round((number - diff),2)
        new_end = round(number,2)
    # If number is within the original range, return the original range
    else:
        return original_range
    
    # Return the adjusted range as a list
    return [new_start, new_end]
 
def all_w_or_l(column_name, df):
    # Check if the column exists in the DataFrame
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")
    
    # Check if all values in the column are either 'W' or 'L'
    if (df[column_name].isin(['W', 'L'])).all():
        return True
    else:
        return False
    
######### Real Trading #############
def realtrade(bList,BotLimit,lvrg,tinfo):
    client = Client(api_key, api_secret)
    mrgType="ISOLATED"
    for Ti,ttype in bList.items():
        Lsafe(client, Ti, mrgType, lvrg)
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="GL" or ttype=="TL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=LongOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,'A',p)
        if ttype=="GS" or ttype=="TS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=ShortOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,'A',p)
        sleep(5)
    while True:
        TLog=TradeLog()
        for x in range(len(TLog)):
            ttype=TLog.iloc[x]['type']
            svresult=TLog.iloc[x]['result']
            Ti=TLog.iloc[x]['token']
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TTREND=super_trend(df)
            TRSI=rsi(df)
            cprice = df['close'].iloc[-1]
            oprice=read_matching_TLog(Ti, 'opprice')
            amount=read_matching_TLog(Ti, 'amount')
            add_token_history(Ti, cprice,TCMF,TRSI,TTREND)
            #i learned something new about if statements
            if svresult!='W' and svresult!='L':
                if ttype=='GL':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'TL')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to TL')
                            update_cell_Tlog(Ti, 'type', 'TL')
                        else:
                            closeLong(client,amount,Ti)
                            if oprice<cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='TL':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'GL')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to GL')
                            update_cell_Tlog(Ti, 'type', 'GL')
                        else:
                            closeLong(client,amount,Ti)
                            if oprice<cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='GS':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'TS')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to TS')
                            update_cell_Tlog(Ti, 'type', 'TS')
                        else:
                            closeShort(client,amount,Ti)
                            if oprice>cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='TS':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'GS')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to GS')
                            update_cell_Tlog(Ti, 'type', 'GS')
                        else:
                            closeShort(client,amount,Ti)
                            if oprice>cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
        TLog=TradeLog()
        if all_w_or_l('result', TLog):
            print("All Trades Done")
            return True
        sleep(300)
    print("All Trades Done")
    return True

#############Logic####################
def simtrade(bList,BotLimit,tinfo):
    client = Client(api_key, api_secret)
    for Ti,ttype in bList.items():
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="GL" or ttype=="TL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'A','0')
        if ttype=="GS" or ttype=="TS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'A','0')
    while True:
        TLog=TradeLog()
        for x in range(len(TLog)):
            ttype=TLog.iloc[x]['type']
            svresult=TLog.iloc[x]['result']
            Ti=TLog.iloc[x]['token']
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TTREND=super_trend(df)
            TRSI=rsi(df)
            cprice = df['close'].iloc[-1]
            oprice=read_matching_TLog(Ti, 'opprice')
            add_token_history(Ti, cprice,TCMF,TRSI,TTREND)
            print(Ti,ttype,cprice,TCMF,TRSI,TTREND)
            #i learned something new about if statements
            if svresult!='W' and svresult!='L':
                if ttype=='GL':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'TL')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to TL')
                            update_cell_Tlog(Ti, 'type', 'TL')
                        else:
                            if oprice<cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='TL':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'GL')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to GL')
                            update_cell_Tlog(Ti, 'type', 'GL')
                        else:
                            if oprice<cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='GS':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'TS')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to TS')
                            update_cell_Tlog(Ti, 'type', 'TS')
                        else:
                            if oprice>cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
                if ttype=='TS':
                    range_intensity=is_between_open(TRSI,TCMF,TTREND,'GS')
                    result,edge_intensity=CloseLayer(TRSI,TCMF,TTREND,ttype)
                    if result==True:
                        if range_intensity>edge_intensity:
                            print(Ti,'switched to GS')
                            update_cell_Tlog(Ti, 'type', 'GS')
                        else:
                            if oprice>cprice:
                                update_cell_Tlog(Ti, 'result', 'W')
                            else:
                                update_cell_Tlog(Ti, 'result', 'L')
                            print("trade closed : ", Ti)
                            break
        TLog=TradeLog()
        if all_w_or_l('result', TLog):
            print("All Trades Done")
            return True
        sleep(300)
    print("All Trades Done")
    return True
        
########trainer############
def main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial):
    client = Client(api_key, api_secret)
    while True:
        balance = client.futures_account_balance()
        bal = None
        for wc in balance:
            if wc["asset"] == 'USDT':
                bal = float(wc["balance"])
        if bal > initial:
            amnt = bal - initial
            client.futures_account_transfer(asset='USDT', amount=amnt, Type=2)
            print("Profit Transfer:", amnt)
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=realtrade(botLimit_tokens,BotLimit,lvrg,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                adjust_and_reflect()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

def simulated_trader(excludedlist,CurrencyType,BotLimit):
    while True:
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=simtrade(botLimit_tokens,BotLimit,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                adjust_and_reflect()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

clear_tradeLog()
clear_Token_History()  
BotLimit=2
print("Booting up... ")
excludedlist=['BTCUSDT','BTCDOMUSDT']
CurrencyType="USDT"
lvrg=2
initial_amt=1000
main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial_amt)
#simulated_trader(excludedlist,CurrencyType,BotLimit)
#Evaluate_Trades()
#adjust_and_reflect()
