# -*- coding: utf-8 -*-
"""
Created on Mon Jan  8 06:16:20 2024

@author: azzy
"""
from keys import *
# importing keys
import multiprocessing
import pandas as pd
import numpy as np #computing multidimensionla arrays
from datetime import datetime
from time import sleep
from binance.client import Client
from binance import *
from binance.enums import *
import math
import pandas_ta as ta
import operator
import os
import sys
import ast
globalInterval=Client.KLINE_INTERVAL_3MINUTE
########close/open trades###########
def Lsafe(client,Seed,mrgType,lvrg):
    try:
        client.futures_change_leverage(symbol=Seed,leverage=lvrg)
        client.futures_change_margin_type(symbol=Seed,marginType=mrgType)
    except:
        return
    
#Precession
def get_current_datetime_as_string():
    current_datetime = datetime.now()
    return current_datetime.strftime("%Y-%m-%d %H:%M:%S")

def truncate(f, n):
    return round(f,n)
#Order System
def LongOrder(client,Seed,precision,numBots,lvrg):
    balance = client.futures_account_balance()
    bal=None
    percent=round((100/numBots)/100,2)
    for wc in balance:
        if wc["asset"]=='USDT':
            bal=float(wc["balance"])
    price = client.futures_mark_price(symbol=Seed)["markPrice"]
    maxl=(bal*percent) * lvrg
    maxq=maxl/ float(price)
    q=truncate(maxq,precision)
    try:
        client.futures_create_order(symbol=Seed,type=ORDER_TYPE_MARKET,side=SIDE_BUY,quantity=str(q))
        return str(q)
    except:
        return "null"
    
def ShortOrder(client,Seed,precision,numBots,lvrg):
    balance = client.futures_account_balance()
    bal=None
    percent=round((100/numBots)/100,3)
    for wc in balance:
        if wc["asset"]=='USDT':
            bal=float(wc["balance"])
    price = client.futures_mark_price(symbol=Seed)["markPrice"]
    maxl=(bal*percent) * lvrg
    maxq=maxl/ float(price)
    q=truncate(maxq,precision)
    try:
        client.futures_create_order(symbol=Seed,type=ORDER_TYPE_MARKET,side=SIDE_SELL,quantity=str(q))
        return str(q)
    except:
        return "null"

def closeLong(client,p,Seed):
    try:
        client.futures_create_order(symbol=Seed,type=ORDER_TYPE_MARKET,side=SIDE_SELL,quantity=p,reduceOnly='true')
    except Exception as e:
        print("exception order Error",e)
        
def closeShort(client,p,Seed):
    try:
        client.futures_create_order(symbol=Seed,type=ORDER_TYPE_MARKET,side=SIDE_BUY,quantity=p,reduceOnly='true')
    except Exception as e:
        print("exception order Error",e)
########close/open trades###########

#################### Get token info #########################

def batchCollector(excludedlist,CurrencyType):
    client = Client(api_key, api_secret)
    exInfo=client.futures_exchange_info()
    tokenInf,sinf=FindNewToken(client,exInfo,excludedlist,CurrencyType)
    Ftoken_list=OpenLayer(tokenInf)
    return Ftoken_list,sinf

def TokenInfo(client,sym,CurrencyType):
    try:
        candles = client.futures_continous_klines(pair=sym, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        return df
    except Exception as e:
        #TokenInfo error Removed from Market or not added yet
        print("TokenInfo error Removed from Market or not added yet",e)

def FindNewToken(client,exInfo,excludedlist,CurrencyType):
    symInfo={}
    tokenInfo={}
    for symbol in exInfo["symbols"]:
        if symbol["contractType"]=="PERPETUAL" and symbol["symbol"] not in excludedlist and CurrencyType in symbol["symbol"] and symbol["status"]=="TRADING":
            symInfo[symbol["symbol"]]=symbol["quantityPrecision"]
    x=0
    for key,values in symInfo.items():
        result=TokenInfo(client,key,CurrencyType)
        tokenInfo[key]=result
        if x==30:
            print("30%")
        if x==80:
            print("80%")
        if x==130:
            print("99%")
        x+=1
    print('100%')            
    return tokenInfo,symInfo

def OpenLayer(TokenInfo):
    ranked_result={}
    trade_types=['GL','GS','TL','TS']
    for Ti,value in TokenInfo.items():
        pressurelist={}
        try:
            TZSCORE=zscore(value)
            TCMF=CMF(value)
            TTREND=super_trend(value)
            TRSI=rsi(value)
            for ttype in trade_types:
                range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[0]
                range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[0]
                trend=ast.literal_eval(read_matching_table('nodes','TREND', ttype))[0]
                range_intensity=is_between(range_rsi,TRSI,range_cmf,TCMF,TTREND,trend,ttype)
                pressurelist[ttype]=round((range_intensity+abs(TZSCORE)),2)
        except Exception as e:
            #TokenInfo error Removed from Market or not added yet
            print("TokenInfo error Removed from Market or not added yet",e) 
        bestchoice=get_key_of_higher_number(pressurelist)
        if pressurelist[bestchoice]>trigger_amount(bestchoice,'open'):
            ranked_result[Ti]=[pressurelist[bestchoice],bestchoice]
    # Sort the keys based on the first element of the list in descending order
    sorted_keys = sorted(ranked_result.keys(), key=lambda x: ranked_result[x][0], reverse=True)
    # Reorganize the dictionary using the sorted keys
    sorted_ranked_result = {key: ranked_result[key] for key in sorted_keys}
    Tresult={}
    for key,item in sorted_ranked_result.items():
        Tresult[key]=item[1]
    return Tresult

def get_key_of_higher_number(dictionary):
    # Initialize variables to keep track of the highest number and its corresponding key
    highest_number = float('-inf')  # Start with a very low number
    highest_key = None

    # Iterate through the dictionary
    for key, value in dictionary.items():
        # If the current value is higher than the highest number found so far
        if value > highest_number:
            highest_number = value
            highest_key = key
    # Return the key corresponding to the highest number
    return highest_key

def get_key_of_lower_number(dictionary):
    # Initialize variables to keep track of the lowest number and its corresponding key
    lowest_number = float('inf')  # Start with a very high number
    lowest_key = None

    # Iterate through the dictionary
    for key, value in dictionary.items():
        # If the current value is lower than the lowest number found so far
        if value < lowest_number:
            lowest_number = value
            lowest_key = key
    # Return the key corresponding to the lowest number
    return lowest_key

def find_largest_number(pressurelist):
    # Initialize the maximum value to the smallest possible integer
    max_value = float('-inf')

    # Iterate through the dictionary
    for value in pressurelist.values():
        # Update the maximum value if the current value is greater
        if value > max_value:
            max_value = value

    return max_value

def CloseLayer(TRSI,TCMF,TTREND,ttype):
    range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))[1]
    range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))[1]
    trend=ast.literal_eval(read_matching_table('nodes','TREND', ttype))[1]
    edge_intensity=is_close(range_rsi,TRSI,range_cmf,TCMF,TTREND,trend,ttype)
    trigger=trigger_amount(ttype,'close')
    if edge_intensity>trigger:
        return True
    else:
        return False

def is_close(range_rsi,TRSI,range_cmf,TCMF,TTREND,trend,ttype):
    RSI_intensity= intensity_from_edge(TRSI, range_rsi[0], range_rsi[1])
    CMF_intensity= intensity_from_edge(TCMF, range_cmf[0], range_cmf[1])
    if trend==TTREND:
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', ttype))[0]
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[0]
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[0]
        average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + trend_w),3)
    else:
        return 0
    return average
    

def is_between(range_rsi,TRSI,range_cmf,TCMF,TTREND,trend,ttype):
    RSI_intensity= intensity_from_mid(TRSI, range_rsi[0], range_rsi[1])
    CMF_intensity= intensity_from_mid(TCMF, range_cmf[0], range_cmf[1])
    if trend==TTREND:
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', ttype))[0]
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF', ttype))[0]
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', ttype))[0]
        average = round(((RSI_intensity*rsi_w) + (CMF_intensity*cmf_w) + trend_w),3)
    else:
        return 0
    return average


#################### Get token info #########################

############# Indicators #############
def super_trend(df, period=7, multiplier=3.0):
    supertrend = df.ta.supertrend(high='high', low='low', close='close', length=period, multiplier=multiplier)
    df = pd.concat([df, supertrend], axis=1)
    latest_trend = 1 if df.iloc[-1]['close'] > df.iloc[-1]['SUPERT_'+str(period)+"_"+str(multiplier)] else 0
    return latest_trend

def CMF(data):
    period = 20
    mf = ((data['close'] - data['low']) - (data['high'] - data['close'])) / (data['high'] - data['low'])
    mfv = mf * data['volume']
    cmf_values = mfv.rolling(period).sum() / data['volume'].rolling(period).sum()
    cmf_values = cmf_values.dropna() 
    return round(cmf_values.iloc[-1],3)

def rsi(dataset):
    S=dataset.ta.rsi(length=14)
    rssi=round(S.iloc[-1],1)
    return rssi

def zscore(dataset):
    zpoints=dataset.ta.zscore().dropna()
    zscore=round(zpoints.iloc[-1],3)
    return zscore


def intensity_from_edge(number, range_start, range_end):
    # Sort the range automatically
    sorted_range = sorted([range_start, range_end])
    range_start, range_end = sorted_range[0], sorted_range[1]

    if range_start == range_end:
        raise ValueError("Range start and end cannot be the same.")
    
    if not (range_start <= number <= range_end):
        return 0  # If the number is out of the specified range, intensity is 0.

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Calculate the distance of the number from the midpoint
    distance_from_midpoint = abs(number - midpoint)

    # Calculate the maximum distance from the midpoint (half the absolute range)
    max_distance = abs(range_end - range_start) / 2

    # Calculate the intensity based on the distance from the midpoint
    # Adjust the calculation to give a higher intensity when further away from the midpoint
    intensity = 1 - (distance_from_midpoint / max_distance)
    # Change the intensity to be higher when closer to the midpoint
    intensity = 1 - intensity

    return intensity

def same_side_check(num1, num2, range_start, range_end):
    # Sort the range automatically
    sorted_range = sorted([range_start, range_end])
    range_start, range_end = sorted_range[0], sorted_range[1]

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Ensure num1 is above the midpoint and num2 is below
    if num1 < midpoint:
        num1, num2 = num2, num1

    # Check if both num1 and num2 are above or below the midpoint
    both_above = num1 > midpoint and num2 > midpoint
    both_below = num1 < midpoint and num2 < midpoint
    return both_above or both_below

def intensity_from_mid(number, range_start, range_end):
    # Sort the range automatically
    sorted_range = sorted([range_start, range_end])
    range_start, range_end = sorted_range[0], sorted_range[1]

    if range_start == range_end:
        raise ValueError("Range start and end cannot be the same.")
    
    if not (range_start <= number <= range_end):
        return 0  # If the number is out of the specified range, intensity is 0.

    # Calculate the midpoint of the range
    midpoint = (range_start + range_end) / 2

    # Calculate the distance of the number from the midpoint
    distance_from_midpoint = abs(number - midpoint)

    # Calculate the maximum distance from the midpoint (half the absolute range)
    max_distance = abs(range_end - range_start) / 2

    # Calculate the intensity based on the distance from the midpoint
    intensity = 1 - (distance_from_midpoint / max_distance)

    return intensity

############# Indicators #############
########################database##############

def nodes():
    if not os.path.exists('nodes.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI', 'CMF','TREND'],
            'GL': ['[[30,35],[65,70]]', '[[-0.2,0],[0,0.2]]','[0,1]'],
            'GS': ['[[65,70],[30,35]]', '[[0,0.2],[-0.2,0]]','[1,0]'],
            'TL': ['[[70,75],[30,25]]', '[[0.2,0.5],[-0.5,-0.2]]','[1,0]'],
            'TS': ['[[30,25],[70,75]]', '[[-0.5,-0.2],[0.2,0.5]]','[0,1]']
            }
        df = pd.DataFrame(data)
        df.to_csv('nodes.csv', index=False)
        return df
    else:
        df=pd.read_csv('nodes.csv')
        return df
def reflections():
    if not os.path.exists('reflections.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'IND': ['RSI','CMF','TREND','TNUM'],
            'GL': ['[6969,6969]','[6969,6969]', '[6969,6969]','0'],
            'GS': ['[6969,6969]','[6969,6969]', '[6969,6969]','0'],
            'TL': ['[6969,6969]','[6969,6969]','[6969,6969]','0'],
            'TS': ['[6969,6969]','[6969,6969]', '[6969,6969]','0']
            }
        df = pd.DataFrame(data)
        df.to_csv('reflections.csv', index=False)
        return df
    else:
        df=pd.read_csv('reflections.csv')
        return df
def weights():
    if not os.path.exists('weights.csv'):
        # Create a DataFrame with the desired structure '[1,1]', '[1,1]', '[1,1]', '[1,1]',
        data = {
            'IND': ['RSI', 'CMF', 'TREND'],
            'GL': ['[1,1]', '[1,1]','[1,1]'],
            'GS': ['[1,1]', '[1,1]','[1,1]'],
            'TL': ['[1,1]', '[1,1]', '[1,1]'],
            'TS': ['[1,1]', '[1,1]', '[1,1]']
            }
        df = pd.DataFrame(data)
        df.to_csv('weights.csv', index=False)
        return df
    else:
        df=pd.read_csv('weights.csv')
        return df
    
def read_matching_table(table,indicator, column_name):
    if table=='nodes':   
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        cell_value = df.iloc[row_index[0], column_index]
        return cell_value
    


def update_cell_table(table,indicator, column_name, new_value):
    if table=='nodes':
        df=nodes()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('nodes.csv', index=False)
        return True
    if table=='weights':
        df=weights()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('weights.csv', index=False)
        return True
    if table=='reflections':
        df=reflections()
        row_index = df.index[df['IND'] == indicator].tolist()
        if not row_index:
            print(f"Indicator '{indicator}' not found.")
            return
        column_index = df.columns.get_loc(column_name)
        df.iloc[row_index[0], column_index] = new_value
        df.to_csv('reflections.csv', index=False)
        return True

def multiTokenHistory():
    if not os.path.exists('multiTokenHistory.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'price': [],
            'CMF': [],
            'RSI': [],
            'TREND': []
        }
        df = pd.DataFrame(data)
        df.to_csv('multiTokenHistory.csv', index=False)
        return df
    else:
        df=pd.read_csv('multiTokenHistory.csv')
        return df

def TradeLog():
    if not os.path.exists('TradeLog.csv'):
        # Create a DataFrame with the desired structure
        data = {
            'token': [],
            'type': [],
            'datetime': [],
            'opprice': [],
            'result':[]
        }
        df = pd.DataFrame(data)
        df.to_csv('TradeLog.csv', index=False)
        return df
    else:
        df=pd.read_csv('TradeLog.csv')
        return df

def clear_tradeLog():
    try:
        os.remove("TradeLog.csv")
        print(" TradeLog.csv deleted successfully.")
    except FileNotFoundError:
        print("File TradeLog.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")

def remove_single_TradeLog(token):
    df=TradeLog()
    index_to_remove = df[df['token'] == token].index[0]
    df = df.drop(index_to_remove)
    df.to_csv('TradeLog.csv', index=False)

def add_tradeLog(Ti, ttype, datetime, opprice,amount):
    dataframe=TradeLog()
    new_row = pd.DataFrame({
        'token': Ti,
        'type': ttype,
        'datetime': datetime,
        'opprice': opprice,
        'amount': amount,
        'result': ''
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv('TradeLog.csv', index=False)
    
def update_cell_Tlog(token, column_name, new_value):
    df=TradeLog()
    row_index = df.index[df['token'] == token ].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    df.iloc[row_index[0], column_index] = new_value
    df.to_csv('TradeLog.csv', index=False)
    return True

def read_matching_TLog(token, column_name):
    df=TradeLog()
    row_index = df.index[df['token'] == token].tolist()
    if not row_index:
        print(f"Indicator '{token}' not found.")
        return
    column_index = df.columns.get_loc(column_name)
    cell_value = df.iloc[row_index[0], column_index]
    return cell_value


def clear_Token_History():
    try:
        os.remove("multiTokenHistory.csv")
        print(" multiTokenHistory.csv deleted successfully.")
    except FileNotFoundError:
        print("File multiTokenHistory.csv not found.")
        pass
    except Exception as e:
        print(f"An error occurred: {e}")
        pass

def filter_multi_trade(column_name, match_string):
    df=multiTokenHistory()
    if column_name not in df.columns:
        raise ValueError(f"Column '{column_name}' does not exist in the DataFrame.")
    # Filter the DataFrame
    filtered_df = df[df[column_name] == match_string]
    return filtered_df        

def add_token_history(sym, cprice, TCMF, TRSI, TTREND):
    dataframe=multiTokenHistory()
    new_row = pd.DataFrame({
        'token': sym,
        'price': cprice,
        'CMF': TCMF,
        'RSI': TRSI,
        'TREND': TTREND
    }, index=[0])  # Ensure it's a single row DataFrame
    
    dataframe = pd.concat([dataframe, new_row], ignore_index=True)
    dataframe.to_csv("multiTokenHistory.csv", index=False)    
########################database##############

###############Logic###################

def bot_limited_Tokens(dictionary, n):
    new_dict = {}
    count = 0
    for key, value in dictionary.items():
        if count < n:
            new_dict[key] = value
            count += 1
        else:
            break
    return new_dict

def price_intensity(ideal_open, ideal_close, actual_open, actual_close):
    # Calculate intensity for opening price
    opening_intensity = abs(ideal_open - actual_open) / abs(ideal_open - ideal_close)
    opening_intensity = min(1, opening_intensity)  # Ensure the result is between 0 and 1
    
    # Calculate intensity for closing price
    closing_intensity = abs(ideal_close - actual_close) / abs(ideal_open - ideal_close)
    closing_intensity = min(1, closing_intensity)  # Ensure the result is between 0 and 1
    return round(opening_intensity,2), round(closing_intensity,2)

def Evaluate_Trades():
    TLog=TradeLog()
    for index,item in TLog.iterrows():
        the_token=item['token']
        trade_type=item['type']
        trade_result=item['result']
        tokenhistory=filter_multi_trade('token', the_token)
        smallest_value = tokenhistory['price'].min()
        largest_value = tokenhistory['price'].max()
        row_with_smallest_value = tokenhistory.index[tokenhistory['price'] == smallest_value][0]
        row_with_largest_value=tokenhistory.index[tokenhistory['price'] == largest_value][0]
        first_price = tokenhistory['price'].iloc[0]
        last_price = tokenhistory['price'].iloc[-1]
        print(row_with_largest_value, row_with_smallest_value)
        print(largest_value, smallest_value)
        if trade_result=="L":
            both_above_or_below = same_side_check( row_with_smallest_value,row_with_largest_value, 0, len(tokenhistory))
            if both_above_or_below==False:
                trade_types=["GL","TL","GS","TS"]
                if row_with_smallest_value<row_with_largest_value:
                    pressurelist={}
                    for ttype in trade_types:
                        range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))
                        range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))
                        TCMF_o=tokenhistory.loc[row_with_smallest_value,'CMF']
                        TTREND_o=tokenhistory.loc[row_with_smallest_value,'TREND']
                        TRSI_o=tokenhistory.loc[row_with_smallest_value,'RSI']
                        TCMF_c=tokenhistory.loc[row_with_largest_value,'CMF']
                        TTREND_c=tokenhistory.loc[row_with_largest_value,'TREND']
                        TRSI_c=tokenhistory.loc[row_with_largest_value,'RSI']
                        opening_intensity=eval_close(range_rsi[0],TRSI_o,range_cmf[0],TCMF_o)
                        close_intensity=eval_close(range_rsi[1],TRSI_c,range_cmf[1],TCMF_c)
                        pressurelist[ttype]=(opening_intensity+close_intensity)/2
                else:
                    pressurelist={}
                    for ttype in trade_types:
                        range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', ttype))
                        range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', ttype))
                        TCMF_c=tokenhistory.loc[row_with_smallest_value,'CMF']
                        TTREND_c=tokenhistory.loc[row_with_smallest_value,'TREND']
                        TRSI_c=tokenhistory.loc[row_with_smallest_value,'RSI']
                        TCMF_o=tokenhistory.loc[row_with_largest_value,'CMF']
                        TTREND_o=tokenhistory.loc[row_with_largest_value,'TREND']
                        TRSI_o=tokenhistory.loc[row_with_largest_value,'RSI']
                        opening_intensity=eval_close(range_rsi[0],TRSI_o,range_cmf[0],TCMF_o)
                        close_intensity=eval_close(range_rsi[1],TRSI_c,range_cmf[1],TCMF_c)
                        pressurelist[ttype]=round((opening_intensity+close_intensity)/2,3)
                bestchoice= get_key_of_lower_number(pressurelist)
                if bestchoice=='GL' or bestchoice=='TL':
                    opening_intensity,closing_intensity=price_intensity(smallest_value, largest_value,first_price, last_price)
                    sub_weights(trade_type, opening_intensity,closing_intensity)
                    updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,bestchoice)
                if bestchoice=='GS' or bestchoice=='TS':
                    opening_intensity,closing_intensity=price_intensity(largest_value, smallest_value,first_price, last_price)
                    sub_weights(trade_type, opening_intensity,closing_intensity)
                    updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,bestchoice)
            else:
                if trade_type=='GL' or trade_type=='TL':
                    opening_intensity,closing_intensity=price_intensity(smallest_value, largest_value,first_price, last_price)
                if trade_type=='GS' or trade_type=='TS':
                    opening_intensity,closing_intensity=price_intensity(largest_value, smallest_value,first_price, last_price)
                sub_weights(trade_type, opening_intensity,closing_intensity)
                TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', trade_type))
                TNUM=TNUM + 1
                update_cell_table('reflections','TNUM', ttype, TNUM)  
        else:
            if trade_type=='GL' or trade_type=='TL':
                opening_intensity,closing_intensity=price_intensity(smallest_value, largest_value,first_price, last_price)
            if trade_type=='GS' or trade_type=='TS':
                opening_intensity,closing_intensity=price_intensity(largest_value, smallest_value,first_price, last_price)
            add_weights(trade_type,opening_intensity,closing_intensity)
            TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', trade_type))
            TNUM=TNUM + 1
            update_cell_table('reflections','TNUM', ttype, TNUM)  
            
def running_average(previous_avg, new_number, total_items):
    if total_items == 0:
        return new_number
    else:
        return (previous_avg * total_items + new_number) / (total_items + 1)  
             
def updatereflections(TCMF_o,TRSI_o,TTREND_o,TCMF_c,TTREND_c,TRSI_c,ttype):
    base=6969
    range_rsi=ast.literal_eval(read_matching_table('reflections','RSI', ttype))
    range_cmf=ast.literal_eval(read_matching_table('reflections','CMF', ttype))
    trend=ast.literal_eval(read_matching_table('reflections','TREND', ttype))
    TNUM=ast.literal_eval(read_matching_table('reflections','TNUM', ttype))
    if range_rsi[0]==base:
        range_rsi=[0,range_rsi[1]]
    if range_rsi[1]==base:
        range_rsi=[range_rsi[0],0]
    if range_cmf[0]==base:
        range_cmf=[0,range_cmf[1]]
    if range_cmf[1]==base:
        range_cmf=[range_cmf[0],0]
    if trend[0]==base:
        trend=[0,trend[1]]
    if trend[1]==base:
        trend=[trend[0],0]   
    range_rsi=str([round(running_average(range_rsi[0], TRSI_o, TNUM),3),round(running_average(range_rsi[1], TRSI_c, TNUM),3)])
    range_cmf=str([round(running_average(range_cmf[0], TCMF_o, TNUM),3),round(running_average(range_cmf[1], TCMF_c, TNUM),3)])
    trend=str([round(running_average(trend[0], TTREND_o, TNUM),1),round(running_average(trend[1], TTREND_c, TNUM),1)])
    update_cell_table('reflections','RSI', ttype, range_rsi)
    update_cell_table('reflections','CMF', ttype, range_cmf)
    update_cell_table('reflections','TREND', ttype, trend)
    TNUM=TNUM + 1
    update_cell_table('reflections','TNUM', ttype, TNUM)
    
def trigger_amount(trade_type,side):
    if side=='open':
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        return round((trend_w[0]+cmf_w[0]+rsi_w[0])/3,2)
    if side=='close':
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        return round((trend_w[1]+cmf_w[1]+rsi_w[1])/3,2)

def range_intensity_scaled(range_list, number):
    # Unpack the range
    start, end = range_list
    
    # Calculate the maximum possible distance
    max_distance = max(abs(start - number), abs(end - number))
    
    # Check if the number is within the range
    if start <= number <= end:
        return False
    else:
        # Calculate the distance to the closest range boundary
        distance_to_start = abs(start - number)
        distance_to_end = abs(end - number)
        min_distance = min(distance_to_start, distance_to_end)
        
        # Scale the distance to a value between 0 and 1
        # Ensure that the maximum distance caps at 1 by using min function
        return min(min_distance / max_distance, 1)

    
def eval_close(range_rsi,TRSI,range_cmf,TCMF):
    rsi_int=range_intensity_scaled(range_rsi,TRSI)
    cmf_int=range_intensity_scaled(range_cmf,TCMF)
    if rsi_int != False and cmf_int != False:
        result = round((rsi_int + cmf_int) / 3 , 3)
        return result
    else:
        return False
        
def sub_weights(trade_type, opening_intensity,close_intensity):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w[0]=round(trend_w[0] - opening_intensity, 2)
    rsi_w[0]=round(rsi_w[0] - opening_intensity, 2)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    cmf_w[0]=round(cmf_w[0] - close_intensity, 2)
    update_cell_table('weights','CMF', trade_type, cmf_w)
    trend_w[1]=round(trend_w[1] - close_intensity, 2)
    rsi_w[1]=round(rsi_w[1] - close_intensity, 2)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    cmf_w[1]=round(cmf_w[1] - close_intensity, 2)
    update_cell_table('weights','CMF', trade_type, cmf_w)

def add_weights(trade_type, opening_intensity,close_intensity):
    trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
    cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
    rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
    trend_w[0]=round(trend_w[0] + opening_intensity, 2)
    rsi_w[0]=round(rsi_w[0] + opening_intensity, 2)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    cmf_w[0]=round(cmf_w[0] + opening_intensity, 2)
    update_cell_table('weights','CMF', trade_type, cmf_w)
    trend_w[1]=round(trend_w[1] + close_intensity, 2)
    rsi_w[1]=round(rsi_w[1] + close_intensity, 2)
    update_cell_table('weights','RSI', trade_type, rsi_w)
    update_cell_table('weights','TREND', trade_type, trend_w)
    cmf_w[1]=round(cmf_w[1] + close_intensity, 2)
    update_cell_table('weights','CMF', trade_type, cmf_w)
    
def check_weights():
    trigger=1
    empty=6969
    t_types=["GL","TL","GS","TS"]
    for trade_type in t_types:
        trend_w=ast.literal_eval(read_matching_table('weights','TREND', trade_type))
        cmf_w=ast.literal_eval(read_matching_table('weights','CMF',trade_type))
        rsi_w=ast.literal_eval(read_matching_table('weights','RSI', trade_type))
        if rsi_w[0]<trigger:
            range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', trade_type))
            ref_rsi=ast.literal_eval(read_matching_table('reflections','RSI', trade_type))   
            if ref_rsi[0]!=empty:
                new_range=str([adjust_range(range_rsi[0], ref_rsi[0]),range_rsi[1]])
                update_cell_table('nodes','RSI', trade_type, new_range)
                update_cell_table('weights','RSI', trade_type,str([1,rsi_w[1]]))
        if rsi_w[1]<trigger:
            range_rsi=ast.literal_eval(read_matching_table('nodes','RSI', trade_type))
            ref_rsi=ast.literal_eval(read_matching_table('reflections','RSI', trade_type))
            if ref_rsi[1]!=empty:
                new_range=str([range_rsi[0],adjust_range(range_rsi[1],ref_rsi[1])])
                update_cell_table('nodes','RSI', trade_type, new_range)
                update_cell_table('weights','RSI', trade_type,str([rsi_w[0],1]))
        if cmf_w[0]<trigger:
            range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', trade_type))
            ref_cmf=ast.literal_eval(read_matching_table('reflections','CMF', trade_type))
            if ref_cmf[0]!=empty:
                new_range=str([adjust_range(range_cmf[0], ref_cmf[0]),range_cmf[1]])
                update_cell_table('nodes','CMF', trade_type, new_range)
                update_cell_table('weights','CMF', trade_type,str([1,cmf_w[1]]))
        if cmf_w[1]<trigger:
            range_cmf=ast.literal_eval(read_matching_table('nodes','CMF', trade_type))
            ref_cmf=ast.literal_eval(read_matching_table('reflections','CMF', trade_type))
            if ref_cmf[1]!=empty:
                new_range=str([range_cmf[0],adjust_range(range_cmf[1], ref_cmf[1])])
                update_cell_table('nodes','CMF', trade_type, new_range)
                update_cell_table('weights','CMF', trade_type,str([cmf_w[0],1]))
        if trend_w[0]<trigger:
            trend=ast.literal_eval(read_matching_table('nodes','TREND', trade_type))
            ref_trend=ast.literal_eval(read_matching_table('reflections','TREND', trade_type))
            if ref_trend[0]!=empty:
                new_range=str([ref_trend[0],trend[1]])
                update_cell_table('nodes','TREND', trade_type, new_range)
                update_cell_table('weights','TREND', trade_type,str([1,trend_w[1]]))
        if trend_w[1]<trigger:
            trend=ast.literal_eval(read_matching_table('nodes','TREND', trade_type))
            ref_trend=ast.literal_eval(read_matching_table('reflections','TREND', trade_type))
            if ref_trend[1]!=empty:
                new_range=str([trend[0],ref_trend[1]])
                update_cell_table('nodes','TREND', trade_type, new_range)
                update_cell_table('weights','TREND', trade_type,str([trend_w[0],1]))
        
def adjust_range(original_range, number):
    # Unpack the original range
    start, end = original_range
    
    # If number is 0, return the original range
    if number == 0:
        return original_range
    
    # Calculate the difference between end and start
    diff = end - start
    
    # If number is less than start, adjust the range
    if number < start:
        new_start = number
        new_end = number + diff
    # If number is greater than end, adjust the range
    elif number > end:
        new_start = number - diff
        new_end = number
    # If number is within the original range, return the original range
    else:
        return original_range
    
    # Return the adjusted range as a list
    return [new_start, new_end]
 

######### Real Trading #############
def realtrade(bList,BotLimit,lvrg,tinfo,):
    client = Client(api_key, api_secret)
    mrgType="ISOLATED"
    for Ti,ttype in bList.items():
        Lsafe(client, Ti, mrgType, lvrg)
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="GL" or ttype=="TL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=LongOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,p)
        if ttype=="GS" or ttype=="TS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            print("added:",Ti,ttype)
            p=ShortOrder(client,Ti,tinfo[Ti],BotLimit,lvrg)
            add_tradeLog(Ti,ttype,datetime,opprice,p)
    #sleep(900)
    while True:
        for Ti,ttype in bList.items():
            items_to_remove = []
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TTREND=super_trend(df)
            TRSI=rsi(df)
            cprice = df['close'].iloc[-1]
            add_token_history(Ti, cprice,TCMF,TRSI,TTREND)
            if CloseLayer(TRSI,TCMF,TTREND,ttype):
                oprice=read_matching_TLog(Ti, 'opprice')
                amount=read_matching_TLog(Ti, 'amount')
                if ttype=='GL' or ttype=='TL':
                    closeLong(client,amount,Ti)
                    if oprice<cprice:
                        update_cell_Tlog(Ti, 'result', 'W')
                    else:
                        update_cell_Tlog(Ti, 'result', 'L')
                if ttype=='GS' or ttype=='TS':
                    closeShort(client,amount,Ti)
                    if oprice>cprice:
                        update_cell_Tlog(Ti, 'result', 'W')
                    else:
                        update_cell_Tlog(Ti, 'result', 'L')
                print("trade closed : ", Ti)    
                items_to_remove.append(Ti)
                print("break from the loop")
                break
        for key in items_to_remove:
            del bList[key]
        if len(bList) == 0:
            break
        items_to_remove = []
        sleep(180)
    print("All Trades Done")
    return True

#############Logic####################
def simtrade(bList,BotLimit,tinfo):
    client = Client(api_key, api_secret)
    for Ti,ttype in bList.items():
        candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
        df = pd.DataFrame(candles)
        df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
        df['timestart'] = df['timestart'] / 1000
        df['timeend'] = df['timeend'] / 1000
        df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
        if ttype=="GL" or ttype=="TL":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'0')
        if ttype=="GS" or ttype=="TS":
            opprice = df['close'].iloc[-1]
            datetime=get_current_datetime_as_string()
            #add real Trade command here
            print("added:",Ti,ttype)
            add_tradeLog(Ti,ttype,datetime,opprice,'0')
    #sleep(900)
    while True:
        for Ti,ttype in bList.items():
            items_to_remove = []
            candles = client.futures_continous_klines(pair=Ti, interval=globalInterval,ContractType='PERPETUAL')
            df = pd.DataFrame(candles)
            df.columns = ['timestart', 'open', 'high', 'low', 'close', 'volume', 'timeend', 'quote_asset_volume', 'number_of_trades', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'unused_field']
            df['timestart'] = df['timestart'] / 1000
            df['timeend'] = df['timeend'] / 1000
            df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']] = df[['open', 'high', 'low', 'close', 'volume', 'quote_asset_volume', 'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume']].astype(float)
            TCMF=CMF(df)
            TTREND=super_trend(df)
            TRSI=rsi(df)
            cprice = df['close'].iloc[-1]
            add_token_history(Ti, cprice,TCMF,TRSI,TTREND)
            print("TokenHistoryadded:" ,Ti,cprice,TCMF,TRSI,TTREND)
            print("CloseLayer:" ,Ti,CloseLayer(TRSI,TCMF,TTREND,ttype))
            if CloseLayer(TRSI,TCMF,TTREND,ttype):
                oprice=read_matching_TLog(Ti, 'opprice')
                if ttype=='GL' or ttype=='TL':
                    if oprice<cprice:
                        update_cell_Tlog(Ti, 'result', 'W')
                    else:
                        update_cell_Tlog(Ti, 'result', 'L')
                if ttype=='GS' or ttype=='TS':
                    if oprice>cprice:
                        update_cell_Tlog(Ti, 'result', 'W')
                    else:
                        update_cell_Tlog(Ti, 'result', 'L')
                print("trade closed : ", Ti)    
                items_to_remove.append(Ti)
                print("break from the loop")
                break
        for key in items_to_remove:
            del bList[key]
        if len(bList) == 0:
            break
        items_to_remove = []
        sleep(180)
    print("All Trades Done")
    return True
        
########trainer############
def main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial):
    client = Client(api_key, api_secret)
    while True:
        balance = client.futures_account_balance()
        bal = None
        for wc in balance:
            if wc["asset"] == 'USDT':
                bal = float(wc["balance"])
        if bal > initial:
            amnt = bal - initial
            client.futures_account_transfer(asset='USDT', amount=amnt, Type=2)
            print("Profit Transfer:", amnt)
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=realtrade(botLimit_tokens,BotLimit,lvrg,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                check_weights()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

def simulated_trader(excludedlist,CurrencyType,BotLimit):
    while True:
        TokenList,tinfo = batchCollector(excludedlist,CurrencyType)
        if len(TokenList)>0:
            botLimit_tokens=bot_limited_Tokens(TokenList,BotLimit)
            print(botLimit_tokens)
            result=simtrade(botLimit_tokens,BotLimit,tinfo)
            if result==True:
                print("Now Evaluate")
                Evaluate_Trades()
                check_weights()
                clear_Token_History()
                clear_tradeLog()
        print("sleeping waiting for next cycle")
        sleep(60)

clear_tradeLog()
clear_Token_History()  
BotLimit=5
print("Booting up... ")
excludedlist=['BTCUSDT','BTCDOMUSDT']
CurrencyType="USDT"
lvrg=2
initial_amt=40
#main_trader(excludedlist,CurrencyType,BotLimit,lvrg,initial_amt)
simulated_trader(excludedlist,CurrencyType,BotLimit)
#Evaluate_Trades()
#check_weights()    
